<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WatchRank (Google Sheets)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* --- Base Styles --- */
:root {
  --background: #f4f4f9;
  --card-bg: #ffffff;
  --text-primary: #1a1a1a;
  --text-secondary: #666;
  --accent: #4a67e2;
  --border-color: #e0e0e0;
  --upvote-color: #27ae60;
  --downvote-color: #e74c3c;
  --shadow: 0 4px 12px rgba(0,0,0,0.08);
  --comment-bg: #f8f9fa;
  --comment-text: #777;
  --panel-bg: #ffffff;
  --panel-shadow: 0 8px 32px rgba(0,0,0,0.12);
}
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html, body {
  max-width: 100%;
  overflow-x: hidden;
}
body {
  font-family: 'Inter', sans-serif;
  background-color: var(--background);
  color: var(--text-primary);
  line-height: 1.6;
}
.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 24px 16px;
  width: 100%;
}
header {
  text-align: center;
  margin-bottom: 32px;
}
header h1 {
  font-size: 2.5em;
  font-weight: 700;
}
.status-bar {
  font-size: 0.9em;
  color: var(--text-secondary);
  margin-bottom: 12px;
  text-align: center;
  min-height: 1.2em;
  transition: color 0.3s;
}

/* --- Add Item Form & Suggestions --- */
.add-item-form-container {
  position: relative;
  margin-bottom: 32px;
}
.add-item-form {
  display: flex;
  gap: 12px;
  background: var(--card-bg);
  padding: 16px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}
#item-title-input {
  flex-grow: 1;
  border: 1px solid var(--border-color);
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 16px; /* Important for iOS to prevent zoom */
  min-width: 0;
}
#item-title-input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(74, 103, 226, 0.15);
}
#add-item-btn {
  border: none;
  background: var(--accent);
  color: #fff;
  padding: 0 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s;
  white-space: nowrap;
}
#add-item-btn:disabled {
  background-color: var(--text-secondary);
  cursor: not-allowed;
}
#suggestions-box {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 0 0 12px 12px;
  box-shadow: var(--shadow);
  z-index: 10;
  max-height: 300px;
  overflow-y: auto;
  margin-top: -12px;
  padding-top: 12px;
}
.suggestion-item {
  padding: 10px 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 12px;
  word-break: break-word;
  transition: background-color 0.2s;
}
.suggestion-item:hover {
  background-color: var(--background);
}
.suggestion-item img {
  width: 40px;
  height: 60px;
  object-fit: cover;
  border-radius: 4px;
  background: #eee;
  flex-shrink: 0;
}

/* --- Item List & Cards --- */
.item-list {
  display: grid;
  gap: 20px;
  width: 100%;
}
.item-card {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  background: var(--card-bg);
  padding: 16px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  width: 100%;
  overflow: hidden;
  position: relative;
}
.item-card-rank {
  font-size: 1.5em;
  font-weight: 700;
  color: var(--text-secondary);
  width: 40px;
  text-align: center;
  padding-top: 4px;
  flex-shrink: 0;
}
.item-card-poster {
  width: 80px;
  height: 120px;
  object-fit: cover;
  border-radius: 8px;
  background: #eee;
  flex-shrink: 0;
}
.item-card-content {
  min-width: 0;
  flex-grow: 1;
  overflow: hidden;
}
.item-card-title {
  font-size: 1.25em;
  font-weight: 600;
  margin-bottom: 4px;
  word-break: break-word;
  hyphens: auto;
}
.item-card-meta {
  font-size: 0.9em;
  color: var(--text-secondary);
  background: var(--background);
  display: inline-block;
  padding: 2px 8px;
  border-radius: 12px;
  font-weight: 500;
  margin-bottom: 12px;
}
.item-card-voting {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}
.vote-btn {
  background: none;
  border: 1px solid var(--border-color);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex-shrink: 0;
}
.vote-btn svg {
  width: 20px;
  height: 20px;
  fill: var(--text-secondary);
}
.vote-btn.up.voted {
  background: var(--upvote-color);
  border-color: var(--upvote-color);
}
.vote-btn.up.voted svg {
  fill: white;
}
.vote-btn.down.voted {
  background: var(--downvote-color);
  border-color: var(--downvote-color);
}
.vote-btn.down.voted svg {
  fill: white;
}
.vote-count {
  font-size: 1.25em;
  font-weight: 700;
  min-width: 40px;
  text-align: center;
}
.vote-count.positive {
  color: var(--upvote-color);
}
.vote-count.negative {
  color: var(--downvote-color);
}

/* --- Comments Button & Panel --- */
.comments-toggle {
  position: absolute;
  top: 16px;
  right: 16px;
  background: none;
  border: 1px solid var(--border-color);
  width: 36px;
  height: 36px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  z-index: 2;
}
.comments-toggle:hover {
  background: var(--background);
  border-color: var(--accent);
}
.comments-toggle svg {
  width: 18px;
  height: 18px;
  fill: var(--text-secondary);
  transition: transform 0.2s;
}
.comments-toggle.active svg {
  transform: rotate(180deg);
  fill: var(--accent);
}
.comments-toggle.active {
  background: var(--accent);
}
.comments-toggle.active svg {
  fill: white;
}

.comments-count {
  position: absolute;
  top: -6px;
  right: -6px;
  background: var(--accent);
  color: white;
  font-size: 11px;
  font-weight: 600;
  min-width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.5);
  transition: all 0.2s;
}
.comments-count.visible {
  opacity: 1;
  transform: scale(1);
}

.comments-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 400px;
  height: 100vh;
  background: var(--panel-bg);
  box-shadow: var(--panel-shadow);
  z-index: 1000;
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
}
.comments-panel.open {
  right: 0;
}

.comments-header {
  padding: 20px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.comments-header h3 {
  font-size: 1.1em;
  font-weight: 600;
  margin: 0;
}
.close-comments {
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}
.close-comments:hover {
  background: var(--background);
}
.close-comments svg {
  width: 18px;
  height: 18px;
  fill: var(--text-secondary);
}

.comments-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.comments-list {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.comment {
  background: var(--comment-bg);
  padding: 12px 16px;
  border-radius: 12px;
  border: 1px solid #f0f0f0;
  word-break: break-word;
}
.comment .comment-user {
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 4px;
  display: block;
}
.comment .comment-text {
  color: var(--comment-text);
  line-height: 1.4;
}

.comment-form {
  padding: 20px;
  border-top: 1px solid var(--border-color);
  display: flex;
  gap: 12px;
}
.comment-input {
  flex: 1;
  border: 1px solid var(--border-color);
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 14px;
  min-width: 0;
}
.comment-input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(74, 103, 226, 0.15);
}
.comment-btn {
  border: none;
  background: var(--accent);
  color: white;
  padding: 0 20px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s;
  white-space: nowrap;
}
.comment-btn:hover {
  background: #3a57d1;
}

.comments-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s;
}
.comments-overlay.visible {
  opacity: 1;
  visibility: visible;
}

.empty-state {
  text-align: center;
  color: var(--text-secondary);
  padding: 40px;
  background: var(--card-bg);
  border-radius: 12px;
}

.empty-comments {
  text-align: center;
  color: var(--text-secondary);
  padding: 40px 20px;
  font-size: 0.9em;
}

/* --- Mobile-Friendly Adjustments --- */
@media (max-width: 768px) {
  .comments-panel {
    width: 100%;
    right: -100%;
  }
  
  body {
    font-size: 14px;
  }
  .container {
    padding: 12px 8px;
  }
  header h1 {
    font-size: 1.8em;
  }
  .add-item-form {
    flex-direction: column;
    gap: 8px;
    padding: 12px;
  }
  #add-item-btn {
    width: 100%;
    padding: 12px;
  }
  .item-card {
    gap: 10px;
    padding: 12px 10px;
    margin: 0 2px;
  }
  .item-card-poster {
    width: 50px;
    height: 75px;
  }
  .item-card-rank {
    width: 25px;
    font-size: 1em;
  }
  .item-card-title {
    font-size: 1em;
    line-height: 1.3;
  }
  .item-card-voting {
    gap: 8px;
    margin-bottom: 12px;
  }
  .vote-btn {
    width: 35px;
    height: 35px;
  }
  .vote-btn svg {
    width: 16px;
    height: 16px;
  }
  .vote-count {
    min-width: 25px;
    font-size: 1.1em;
  }
  .suggestion-item {
    padding: 8px 12px;
    gap: 8px;
  }
  .suggestion-item img {
    width: 30px;
    height: 45px;
  }
  .comments-toggle {
    width: 32px;
    height: 32px;
  }
  .comments-toggle svg {
    width: 16px;
    height: 16px;
  }
}
@media (max-width: 480px) {
  .container {
    padding: 8px 4px;
  }
  .item-card {
    padding: 10px 8px;
    gap: 8px;
  }
  .item-card-rank {
    font-size: 0.9em;
    width: 20px;
  }
  .item-card-poster {
    width: 40px;
    height: 60px;
  }
  .item-card-title {
    font-size: 0.95em;
  }
  .vote-btn {
    width: 32px;
    height: 32px;
  }
  .vote-btn svg {
    width: 14px;
    height: 14px;
  }
}
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>WatchRank</h1>
    <div class="status-bar" id="status"></div>
  </header>

  <div class="add-item-form-container">
    <div class="add-item-form">
      <input type="text" id="item-title-input" placeholder="Enter a movie or TV show title..." autocomplete="off">
      <button id="add-item-btn">Add</button>
    </div>
    <div id="suggestions-box"></div>
  </div>

  <div class="item-list" id="item-list">
  </div>
</div>

<!-- Comments Panel -->
<div class="comments-overlay" id="comments-overlay"></div>
<div class="comments-panel" id="comments-panel">
  <div class="comments-header">
    <h3 id="comments-title">Comments</h3>
    <button class="close-comments" id="close-comments">
      <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
    </button>
  </div>
  <div class="comments-content">
    <div class="comments-list" id="comments-list-panel">
      <div class="empty-comments">No comments yet. Be the first to share your thoughts!</div>
    </div>
    <div class="comment-form">
      <input type="text" class="comment-input" id="panel-comment-input" placeholder="Share your thoughts...">
      <button class="comment-btn" id="panel-comment-btn">Post</button>
    </div>
  </div>
</div>

<script>
/**
 * WatchRank Application - Improved Version
 * Fixes autocomplete behavior, save issues, and improves comments UI
 */
(() => {
  // ---------- 1. CONFIGURATION ----------
  const config = {
    SHEET_WEB_APP_URL: 'https://script.google.com/macros/s/AKfycbyqXwU5IcX1xgZYPpjC0deL5vdH60NHyEqrIcbTVeWJzKqnNKU-ptCIpGT9HtrUuMM7/exec',
    TMDB_API_KEY: '269a5d47b3552e41b40624c646f09456',
    POLL_INTERVAL_MS: 15000, // Increased for better debugging
    SUGGESTION_DEBOUNCE_MS: 300,
  };

  // ---------- 2. APPLICATION STATE ----------
  const state = {
    items: [],
    userId: null,
    userName: 'Anonymous',
    isSaving: false,
    isSyncing: false,
    suggestionDebounceTimer: null,
    selectedSuggestion: null,
    currentCommentsItemId: null,
  };

  // ---------- 3. DOM ELEMENT CACHE ----------
  const DOMElements = {
    titleInput: document.getElementById('item-title-input'),
    addButton: document.getElementById('add-item-btn'),
    itemList: document.getElementById('item-list'),
    suggestionsBox: document.getElementById('suggestions-box'),
    statusBar: document.getElementById('status'),
    commentsPanel: document.getElementById('comments-panel'),
    commentsOverlay: document.getElementById('comments-overlay'),
    closeComments: document.getElementById('close-comments'),
    commentsTitle: document.getElementById('comments-title'),
    commentsListPanel: document.getElementById('comments-list-panel'),
    panelCommentInput: document.getElementById('panel-comment-input'),
    panelCommentBtn: document.getElementById('panel-comment-btn'),
  };

  // ---------- 4. UTILITY FUNCTIONS ----------
  const utils = {
    safeJsonParse(str, fallback) { 
      try { 
        return JSON.parse(str); 
      } catch (e) { 
        console.warn('JSON parse error:', e, 'Input:', str);
        return fallback; 
      } 
    },
    escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/[&<>"']/g, s => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[s]));
    },
    debugLog(message, data = null) {
      console.log(`[WatchRank] ${message}`, data || '');
    }
  };

  // ---------- 5. API & DATA HANDLING ----------
  const api = {
    async searchTMDB(query) {
      const url = `https://api.themoviedb.org/3/search/multi?api_key=${config.TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        return data.results || [];
      } catch (err) {
        console.error('TMDb Search Error:', err);
        return [];
      }
    },
    
    async fetchTMDBDetails(id, mediaType) {
      const url = `https://api.themoviedb.org/3/${mediaType}/${id}?api_key=${config.TMDB_API_KEY}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        return {
          title: data.title || data.name,
          type: mediaType === 'movie' ? 'Movie' : 'TV Show',
          posterPath: data.poster_path 
            ? `https://image.tmdb.org/t/p/w500${data.poster_path}` 
            : null
        };
      } catch (err) {
        console.error('TMDb Details Error:', err);
        return null;
      }
    },
    
    async loadItems() {
      if (state.isSyncing) return;
      state.isSyncing = true;
      ui.updateStatus('Syncing...');
      
      try {
        utils.debugLog('Loading items from backend...');
        const res = await fetch(config.SHEET_WEB_APP_URL);
        
        if (!res.ok) {
          throw new Error(`Network response not ok (${res.status}): ${res.statusText}`);
        }
        
        const textResponse = await res.text();
        utils.debugLog('Raw response:', textResponse.substring(0, 200) + '...');
        
        let data;
        try {
          data = JSON.parse(textResponse);
        } catch (parseErr) {
          console.error('Failed to parse response as JSON:', parseErr);
          throw new Error('Invalid JSON response from backend');
        }
        
        if (!Array.isArray(data)) {
          console.error('Invalid data format:', data);
          throw new Error('Backend returned non-array data');
        }
        
        state.items = data.map(raw => ({
          id: Number(raw.id),
          title: raw.title || 'Untitled',
          type: raw.type || 'Movie',
          posterPath: raw.posterPath || null,
          votes: Number(raw.votes) || 0,
          voters: (typeof raw.voters === 'string') ? utils.safeJsonParse(raw.voters, {}) : (raw.voters || {}),
          comments: (typeof raw.comments === 'string') ? utils.safeJsonParse(raw.comments, []) : (raw.comments || []),
        }));

        utils.debugLog(`Loaded ${state.items.length} items`);
        ui.render();
        ui.updateStatus(`Synced ${state.items.length} items at ${new Date().toLocaleTimeString()}`);
        
      } catch (err) {
        console.error('Error loading from sheet:', err);
        ui.updateStatus(`Sync failed: ${err.message}`, true);
      } finally {
        state.isSyncing = false;
      }
    },
    
    async saveItems() {
      if (state.isSaving) return;
      state.isSaving = true;
      ui.updateStatus('Saving...');
      
      try {
        utils.debugLog('Saving items to backend...', state.items);
        
        const payload = { items: state.items };
        const res = await fetch(config.SHEET_WEB_APP_URL, {
          method: 'POST',
          headers: { 
            'Content-Type': 'text/plain;charset=utf-8'
          }, 
          body: JSON.stringify(payload),
        });
        
        if (!res.ok) {
          throw new Error(`Save failed (${res.status}): ${res.statusText}`);
        }
        
        const textResponse = await res.text();
        utils.debugLog('Save response:', textResponse);
        
        let result;
        try {
          result = JSON.parse(textResponse);
        } catch (parseErr) {
          console.error('Failed to parse save response:', parseErr);
          throw new Error('Invalid response from backend after save');
        }
        
        if (result.status !== 'success') {
          throw new Error(result.message || 'Backend returned error status');
        }
        
        ui.updateStatus('Saved successfully!');
        
        // Reload to ensure consistency
        setTimeout(() => this.loadItems(), 1000);
        
      } catch (err) {
        console.error('Error saving to sheet:', err);
        ui.updateStatus(`Save failed: ${err.message}`, true);
      } finally {
        state.isSaving = false;
      }
    },
  };
  
  // ---------- 6. UI & RENDERING ----------
  const ui = {
    render() { 
      state.items.sort((a,b) => b.votes-a.votes); 
      this.renderItemList(); 
      if (state.currentCommentsItemId) {
        this.renderCommentsPanel();
      }
    },
    
    renderItemList() { 
      DOMElements.itemList.innerHTML = ''; 
      if (state.items.length === 0) { 
        DOMElements.itemList.innerHTML = `<p class="empty-state">The list is empty. Add a movie or show to get started!</p>`; 
        return; 
      } 
      
      const fragment = document.createDocumentFragment(); 
      state.items.forEach((item, index) => { 
        const userVote = item.voters[state.userId] || 0; 
        const voteClass = item.votes > 0 ? 'positive' : item.votes < 0 ? 'negative' : ''; 
        const poster = item.posterPath || 'https://via.placeholder.com/80x120.png?text=No+Image'; 
        const card = document.createElement('div'); 
        card.className = 'item-card'; 
        card.dataset.itemId = item.id; 
        
        const commentsCount = item.comments.length;
        
        card.innerHTML = ` 
          <div class="item-card-rank">#${index + 1}</div> 
          <img src="${poster}" alt="${utils.escapeHtml(item.title)} Poster" class="item-card-poster" onerror="this.src='https://via.placeholder.com/80x120.png?text=No+Image'"> 
          <div class="item-card-content"> 
            <h2 class="item-card-title">${utils.escapeHtml(item.title)}</h2> 
            <div class="item-card-meta">${utils.escapeHtml(item.type)}</div> 
            <div class="item-card-voting"> 
              <button class="vote-btn up ${userVote === 1 ? 'voted' : ''}" data-vote-type="up">
                <svg viewBox="0 0 24 24"><path d="M12 4l8 8h-6v8h-4v-8H4l8-8z"></path></svg>
              </button> 
              <div class="vote-count ${voteClass}">${item.votes}</div> 
              <button class="vote-btn down ${userVote === -1 ? 'voted' : ''}" data-vote-type="down">
                <svg viewBox="0 0 24 24"><path d="M12 20l-8-8h6V4h4v8h6l-8 8z"></path></svg>
              </button> 
            </div> 
          </div>
          <button class="comments-toggle" data-item-id="${item.id}">
            <svg viewBox="0 0 24 24"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h11c.55 0 1-.45 1-1z"/></svg>
            <div class="comments-count ${commentsCount > 0 ? 'visible' : ''}">${commentsCount}</div>
          </button>
        `; 
        fragment.appendChild(card); 
      }); 
      DOMElements.itemList.appendChild(fragment); 
    },
    
    renderSuggestions(suggestions) {
      this.hideSuggestions();
      const relevantSuggestions = suggestions
        .filter(s => s.media_type === 'movie' || s.media_type === 'tv')
        .slice(0, 5);
      
      if (relevantSuggestions.length === 0) return;
      
      const fragment = document.createDocumentFragment();
      relevantSuggestions.forEach(s => {
        const el = document.createElement('div');
        el.className = 'suggestion-item';
        
        // Store all necessary data as data attributes
        el.dataset.id = s.id;
        el.dataset.mediaType = s.media_type;
        el.dataset.title = s.title || s.name;
        el.dataset.posterPath = s.poster_path; // Store the partial path
        
        const title = s.title || s.name;
        const year = (s.release_date || s.first_air_date)?.substring(0,4) || 'N/A';
        const poster = s.poster_path 
          ? `https://image.tmdb.org/t/p/w92${s.poster_path}` 
          : 'https://via.placeholder.com/40x60.png?text=N/A';
        
        el.innerHTML = `
          <img src="${poster}" alt="poster">
          <div>
            <div>${utils.escapeHtml(title)}</div>
            <small>${utils.escapeHtml(s.media_type === 'tv' ? 'TV Show' : 'Movie')} (${year})</small>
          </div>
        `;
        fragment.appendChild(el);
      });
      
      DOMElements.suggestionsBox.appendChild(fragment);
      DOMElements.suggestionsBox.style.display = 'block';
    },
    
    hideSuggestions() { 
      DOMElements.suggestionsBox.style.display = 'none'; 
      DOMElements.suggestionsBox.innerHTML = ''; 
    },
    
    renderCommentsPanel() {
      const item = state.items.find(i => i.id === state.currentCommentsItemId);
      if (!item) return;
      
      DOMElements.commentsTitle.textContent = `Comments - ${item.title}`;
      
      if (item.comments.length === 0) {
        DOMElements.commentsListPanel.innerHTML = '<div class="empty-comments">No comments yet. Be the first to share your thoughts!</div>';
      } else {
        DOMElements.commentsListPanel.innerHTML = item.comments.map(comment => `
          <div class="comment">
            <div class="comment-user">${utils.escapeHtml(comment.user)}</div>
            <div class="comment-text">${utils.escapeHtml(comment.text)}</div>
          </div>
        `).join('');
      }
      
      // Scroll to bottom of comments
      DOMElements.commentsListPanel.scrollTop = DOMElements.commentsListPanel.scrollHeight;
    },
    
    openCommentsPanel(itemId) {
      state.currentCommentsItemId = itemId;
      this.renderCommentsPanel();
      DOMElements.commentsPanel.classList.add('open');
      DOMElements.commentsOverlay.classList.add('visible');
      document.body.style.overflow = 'hidden';
      
      // Focus on comment input
      setTimeout(() => {
        DOMElements.panelCommentInput.focus();
      }, 300);
    },
    
    closeCommentsPanel() {
      DOMElements.commentsPanel.classList.remove('open');
      DOMElements.commentsOverlay.classList.remove('visible');
      document.body.style.overflow = '';
      state.currentCommentsItemId = null;
    },
    
    updateStatus(message, isError = false) { 
      DOMElements.statusBar.textContent = message; 
      DOMElements.statusBar.style.color = isError ? 'var(--downvote-color)' : 'var(--text-secondary)'; 
      
      // Clear status after delay if it's a success message
      if (!isError && (message.includes('Saved') || message.includes('Synced'))) {
        setTimeout(() => {
          if (DOMElements.statusBar.textContent === message) {
            DOMElements.statusBar.textContent = '';
          }
        }, 3000);
      }
    },
    
    toggleAddButton(enabled, text = 'Add') { 
      DOMElements.addButton.disabled = !enabled; 
      DOMElements.addButton.textContent = text; 
    },
  };

  // ---------- 7. EVENT HANDLERS ----------
  const handlers = {
    async handleAddItem() {
      const title = DOMElements.titleInput.value.trim();
      if (!title && !state.selectedSuggestion) return;
      
      ui.toggleAddButton(false, 'Adding...');
      
      try {
        let mediaData = null;
        
        // Prioritize using data from a clicked suggestion
        if (state.selectedSuggestion) {
          const { title: suggestedTitle, posterPath, mediaType } = state.selectedSuggestion;
          mediaData = {
            title: suggestedTitle,
            type: mediaType === 'movie' ? 'Movie' : 'TV Show',
            posterPath: posterPath ? `https://image.tmdb.org/t/p/w500${posterPath}` : null
          };
          utils.debugLog('Using selected suggestion:', mediaData);
        } else {
          // Fallback to searching if user just typed and pressed Enter
          utils.debugLog('Searching for:', title);
          const searchResults = await api.searchTMDB(title);
          const firstResult = searchResults.find(s => s.media_type === 'movie' || s.media_type === 'tv');
          if (!firstResult) { 
            throw new Error('Could not find that title. Try selecting from the suggestions dropdown.'); 
          }
          
          mediaData = await api.fetchTMDBDetails(firstResult.id, firstResult.media_type);
          if (!mediaData) { 
            throw new Error('Could not get details for that title.'); 
          }
        }
        
        // Check for duplicates
        if (state.items.some(i => i.title.toLowerCase() === mediaData.title.toLowerCase())) {
          throw new Error(`"${mediaData.title}" is already on the list.`);
        }
        
        const newItem = {
          id: Date.now(),
          title: mediaData.title,
          type: mediaData.type,
          posterPath: mediaData.posterPath,
          votes: 0,
          voters: {},
          comments: []
        };
        
        utils.debugLog('Adding new item:', newItem);
        
        state.items.push(newItem);
        DOMElements.titleInput.value = '';
        state.selectedSuggestion = null;
        ui.hideSuggestions();
        ui.render();
        
        // Save to backend
        await api.saveItems();

      } catch (err) {
        alert(err.message);
        console.error('Error adding item:', err);
        ui.updateStatus(`Failed to add: ${err.message}`, true);
      } finally {
        ui.toggleAddButton(true);
      }
    },
    
    handleVote(e) {
      const button = e.target.closest('.vote-btn');
      if (!button || state.isSaving) return;
      
      const card = button.closest('.item-card');
      const itemId = Number(card.dataset.itemId);
      const voteType = button.dataset.voteType;
      const item = state.items.find(i => i.id === itemId);
      if (!item) return;
      
      const voteValue = voteType === 'up' ? 1 : -1;
      const currentVote = item.voters[state.userId] || 0;
      item.voters[state.userId] = (currentVote === voteValue) ? 0 : voteValue;
      item.votes = Object.values(item.voters).reduce((sum, vote) => sum + vote, 0);
      
      utils.debugLog(`Vote: ${voteType} for "${item.title}", new total: ${item.votes}`);
      
      ui.render();
      api.saveItems();
    },
    
    handleAddComment() {
      const text = DOMElements.panelCommentInput.value.trim();
      if (!text || !state.currentCommentsItemId || state.isSaving) return;
      
      const item = state.items.find(i => i.id === state.currentCommentsItemId);
      if (!item) return;
      
      const newComment = { 
        user: state.userName, 
        text: text, 
        timestamp: Date.now() 
      };
      
      item.comments.push(newComment);
      DOMElements.panelCommentInput.value = '';
      
      utils.debugLog(`Comment added to "${item.title}":`, newComment);
      
      ui.render(); // This will update both main list and comments panel
      api.saveItems();
    },
    
    handleCommentsToggle(e) {
      const button = e.target.closest('.comments-toggle');
      if (!button) return;
      
      const itemId = Number(button.dataset.itemId);
      ui.openCommentsPanel(itemId);
    },
    
    handleTitleInput() {
      clearTimeout(state.suggestionDebounceTimer);
      state.selectedSuggestion = null; // Reset selection on type
      
      const query = DOMElements.titleInput.value.trim();
      if (query.length < 3) {
        ui.hideSuggestions();
        return;
      }
      
      state.suggestionDebounceTimer = setTimeout(async () => {
        const suggestions = await api.searchTMDB(query);
        ui.renderSuggestions(suggestions);
      }, config.SUGGESTION_DEBOUNCE_MS);
    },
    
    async handleSuggestionClick(e) {
      const suggestionItem = e.target.closest('.suggestion-item');
      if (!suggestionItem) return;
      
      // Store the selected suggestion's data
      state.selectedSuggestion = { ...suggestionItem.dataset };
      
      DOMElements.titleInput.value = state.selectedSuggestion.title;
      ui.hideSuggestions();
      
      // Auto-add the item immediately when clicking suggestion
      utils.debugLog('Auto-adding suggestion:', state.selectedSuggestion);
      await handlers.handleAddItem();
    }
  };

  // ---------- 8. INITIALIZATION ----------
  function init() {
    if (!config.SHEET_WEB_APP_URL || !config.TMDB_API_KEY) { 
      ui.updateStatus('Configuration Error: Missing API keys', true); 
      return; 
    }
    
    // Generate or retrieve user ID
    state.userId = localStorage.getItem('watchRankUserId') || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem('watchRankUserId', state.userId);
    
    // Get or prompt for username
    state.userName = localStorage.getItem('watchRankUserName');
    if (!state.userName) { 
      const name = prompt('Enter a display name:', 'MovieFan'); 
      state.userName = (name || 'Anonymous').trim(); 
      localStorage.setItem('watchRankUserName', state.userName); 
    }

    utils.debugLog('Initialized with user:', { id: state.userId, name: state.userName });

    // Event listeners for main form
    DOMElements.addButton.addEventListener('click', handlers.handleAddItem);
    DOMElements.titleInput.addEventListener('input', handlers.handleTitleInput);
    DOMElements.titleInput.addEventListener('keypress', (e) => { 
      if (e.key === 'Enter') { 
        e.preventDefault(); 
        handlers.handleAddItem(); 
      } 
    });
    
    // Event listeners for item interactions
    DOMElements.itemList.addEventListener('click', e => { 
      handlers.handleVote(e); 
      handlers.handleCommentsToggle(e);
    });
    
    // Event listeners for suggestions
    DOMElements.suggestionsBox.addEventListener('click', handlers.handleSuggestionClick);
    document.addEventListener('click', (e) => { 
      if (!e.target.closest('.add-item-form-container')) {
        ui.hideSuggestions(); 
      }
    });

    // Event listeners for comments panel
    DOMElements.closeComments.addEventListener('click', ui.closeCommentsPanel);
    DOMElements.commentsOverlay.addEventListener('click', ui.closeCommentsPanel);
    DOMElements.panelCommentBtn.addEventListener('click', handlers.handleAddComment);
    DOMElements.panelCommentInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handlers.handleAddComment();
      }
    });

    // ESC key to close comments panel
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && state.currentCommentsItemId) {
        ui.closeCommentsPanel();
      }
    });

    // Initial load and setup polling
    api.loadItems().then(() => {
      setInterval(() => {
        if (!state.isSaving && !state.isSyncing) {
          api.loadItems();
        }
      }, config.POLL_INTERVAL_MS);
    });
  }

  // Start the application
  document.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>